<div id="s:shell:wildcard:lesson" class="lesson">

  <p>Let us use the basic commands we already know to explore wildcard
    characters.  We will start in our current directory, and create
    two files:</p>
<pre>
$ <span class="in">touch file1.txt file2.txt</span>
$
</pre>
  <p>The asterisk wildcard <code>*</code> matches zero or more
  characters.  When we ask the shell to list files in a directory by
  matching a wildcard pattern, like <code>ls *</code>, the shell
  carries out a process called globbing, or matching a pattern to
  filenames:</p>
<pre>
$ <span class="in">ls file*</span>
<span class="out">file1.txt   file2.txt</span>
$
</pre>
  <p>There are four other basic wildcard characters we will explore.
  (1) The question mark, <code>?</code>, matches any single character,
  so text?.txt would match text1.txt or textz.txt. (2) The square
  brackets, <code>[]</code>, which specifies either a natural sequence
  (i.e. text[1-6].txt would match text1.txt, text2.txt, ...,
  text6.txt), or a logical or between characters (i.e. text[135].txt
  would match text1.txt text3.txt and text5.txt). (3) The curly
  braces, <code>{}</code>, which expands comma delimited items and
  matches to each expanded item (i.e. text{1,5}.txt expands to
  text1.txt text5.txt, so the glob would match either of
  these). Note, we can also shorthand any natural sequence in the
  curly braces, i.e. text{1..5}.txt would expand to everything
  between text1.txt text2.txt ... text5.txt.  Let us begin by
  creating empty files using the touch command and the curly braces:</p>

<pre>
$ <span class="in">touch file{4,6,7}.txt file_{a..e}.txt</span>
$ 
</pre>

<p>Recall, that the curly braces expand the second token into three
  separate file names, and the third token expands into 5 separate
  file names.  So, now if we list files using the asterisk wildcard,
  we get:</p>

<pre>
$ <span class="in">ls file*</span>
<span class="out">file4.txt   file7.txt    file_b.txt   file_d.txt</span>
<span class="out">file6.txt   file_a.txt   file_c.txt   file_e.txt</span>
$
</pre>

<p>We have matched all files in our current directory that begin
with <code>file</code>.  Now, let us list a subset of those files using
the question mark:</p>

<pre>
$ <span class="in">ls file?.txt</span>
<span class="out">file4.txt   file6.txt    file7.txt</span>
$
</pre>

<p> Note, how this glob pattern matched only the numbered files.  That
  is because only the numbered files have a single character
  between <code>file</code> and <code>.txt</code>.  The lettered files
  have two characters:</p>

<pre>
$ <span class="in">ls file??.txt</span>
<span class="out">file_a.txt   file_b.txt    file_c.txt   file_d.txt   file_e.txt</span>
$
</pre>

  <p>
    We can use the <code>!</code> character with square brackets to mean 
    negation of the following characters inside the square brackets.  For 
    example, <code>file[!46]*</code> would match everything beginning with 
    "file", <em>unless</em> the next character is a 4 or a 6.  Thus, 
    continuing with our example, if we do <code>rm file[!46]*</code>, we 
    will delete everything except <code>file4.txt</code> and 
    <code>file6.txt</code>:
  </p>

<pre>
$ <span class="in">ls</span>
<span class="out">file4.txt   file7.txt    file_b.txt   file_d.txt</span>
<span class="out">file6.txt   file_a.txt   file_c.txt   file_e.txt</span>
$ <span class="in">rm file[!46]*</span>
$ <span class="in">ls</span>
<span class="out">file4.txt   file6.txt</span>
$
</pre>

  <p>
    It's also possible to combine and nest wildcards.  For example, 
    <code>file{4,_?}.txt</code> would match <code>file4.txt</code> 
    and <code>file_?.txt</code>, where <code>?</code> matches any 
    single character. To demonstrate this, let's re-create all of 
    our files:
  </p>

<pre>
$ <span class="in">touch file{4,6,7}.txt file_{a..e}.txt</span>
$ <span class="in">ls</span>
<span class="out">file4.txt   file7.txt    file_b.txt   file_d.txt</span>
<span class="out">file6.txt   file_a.txt   file_c.txt   file_e.txt</span>
$ 
</pre>

  <p>
    Now let's <code>ls file{4,_?}.txt</code>:
  </p>

<pre>
$ <span class="in">ls file{4,_?}.txt</span>
<span class="out">file4.txt   file_b.txt   file_d.txt</span>
<span class="out">file_a.txt   file_c.txt   file_e.txt</span>
$
</pre>

  <p>
    Finally, it is important to understand what happens if a 
    wildcard expression doesn't match any files.  In this case, 
    the wildcard characters are interpreted literally.  For 
    example, if we were to enter <code>ls file[AB].txt</code>,
    the system will first try to find <code>fileA.txt</code> or
    <code>fileB.txt</code>, but when it fails to find either of
    those, it will try to find a file named <code>file[AB].txt</code>.
  </p>

</div>
