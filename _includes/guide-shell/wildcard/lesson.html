<div id="s:shell:wildcard:lesson" class="lesson">

  <p>
    At this point we have a basic toolkit which allows us to do
    things in the shell that you can normally do in Windows or
    Mac OS with your mouse.  For example, we can create, delete
    and move individual files.  We will now learn about wildcards
    which will allow us to expand our toolkit so that we can do
    things to multiple files with a single command.
    We'll start in an empty directory and create four files:
  </p>
<pre>
$ <span class="in">touch file1.txt file2.txt otherfile1.txt otherfile2.txt</span>
$ <span class="in">ls</span>
<span class="out">file1.txt   file2.txt   otherfile1.txt   otherfile2.txt</span>
$
</pre>

  <p>
    If we want to see all filenames that start with "file", we can run the
    command <code>ls file*</code>:
  </p>

<pre>
$ <span class="in">ls file*</span>
<span class="out">file1.txt   file2.txt</span>
$
</pre>

  <p>
    The asterisk wildcard <code>*</code> in <code>file*</code> matches zero
    or more characters of any kind.  Thus the expression <code>file*</code>
    matches anything that starts with "file".  On the other hand, the 
    expression <code>*file*</code> would match all of the files currently
    in the directory because they all have the word "file" somewhere in
    their filename.
  </p>

  <p>
    <em>The <code>*</code> in <code>*.pdb</code> matches zero or more characters,
    so the shell turns <code>*.pdb</code> into a complete list of <code>.pdb</code> files: </em>
  </p>

  <p>The asterisk wildcard <code>*</code> matches zero or more
  characters.  When we ask the shell to list files in a directory by
  matching a wildcard pattern, like <code>ls *</code>, the shell
  carries out a process called globbing, or matching a pattern to
  filenames:</p>

  <div class="box" id="a:wildcard">
    <h3>Wildcards</h3>

    <p>
      <code>*</code> is a <a href="glossary.html#wildcard">wildcard</a>.
      It matches zero or more characters,
      so <code>*.pdb</code> matches <code>ethane.pdb</code>,
      <code>propane.pdb</code>,
      and so on.
      On the other hand,
      <code>p*.pdb</code> only matches <code>pentane.pdb</code> and <code>propane.pdb</code>,
      because the 'p' at the front only matches itself.
    </p>

    <p>
      <code>?</code> is also a wildcard,
      but it only matches a single character.
      This means that <code>p?.pdb</code> matches <code>pi.pdb</code> or <code>p5.pdb</code>,
      but not <code>propane.pdb</code>.
      We can use any number of wildcards at a time:
      for example,
      <code>p*.p?*</code> matches anything that starts with a 'p'
      and ends with '.', 'p', and at least one more character
      (since the '?' has to match one character,
      and the final '*' can match any number of characters).
      Thus,
      <code>p*.p?*</code> would match
      <code>preferred.practice</code>,
      and even <code>p.pi</code>
      (since the first '*' can match no characters at all),
      but not <code>quality.practice</code> (doesn't start with 'p')
      or <code>preferred.p</code> (there isn't at least one character after the '.p').
    </p>

    <p>
      When the shell sees a wildcard,
      it expands it to create a list of filenames
      <em>before</em> passing those names to whatever command is being run.
      This means that commands like <code>wc</code> and <code>ls</code> never see the wildcard characters,
      just what those wildcards matched.
      This is another example of orthogonal design.
    </p>

  </div>



  <p>There are four other basic wildcard characters we will explore.
  (1) The question mark, <code>?</code>, matches any single character,
  so text?.txt would match text1.txt or textz.txt. (2) The square
  brackets, <code>[]</code>, which specifies either a natural sequence
  (i.e. text[1-6].txt would match text1.txt, text2.txt, ...,
  text6.txt), or a logical or between characters (i.e. text[135].txt
  would match text1.txt text3.txt and text5.txt). (3) The curly
  braces, <code>{}</code>, which expands comma delimited items and
  matches to each expanded item (i.e. text{1,5}.txt expands to
  text1.txt text5.txt, so the glob would match either of
  these). Note, we can also shorthand any natural sequence in the
  curly braces, i.e. text{1..5}.txt would expand to everything
  between text1.txt text2.txt ... text5.txt.  Let us begin by
  creating empty files using the touch command and the curly braces:</p>

<pre>
$ <span class="in">touch file{4,6,7}.txt file_{a..e}.txt</span>
$ 
</pre>

<p>Recall, that the curly braces expand the second token into three
  separate file names, and the third token expands into 5 separate
  file names.  So, now if we list files using the asterisk wildcard,
  we get:</p>

<pre>
$ <span class="in">ls file*</span>
<span class="out">file4.txt   file7.txt    file_b.txt   file_d.txt</span>
<span class="out">file6.txt   file_a.txt   file_c.txt   file_e.txt</span>
$
</pre>

<p>We have matched all files in our current directory that begin
with <code>file</code>.  Now, let us list a subset of those files using
the question mark:</p>

<pre>
$ <span class="in">ls file?.txt</span>
<span class="out">file4.txt   file6.txt    file7.txt</span>
$
</pre>

<p> Note, how this glob pattern matched only the numbered files.  That
  is because only the numbered files have a single character
  between <code>file</code> and <code>.txt</code>.  The lettered files
  have two characters:</p>

<pre>
$ <span class="in">ls file??.txt</span>
<span class="out">file_a.txt   file_b.txt    file_c.txt   file_d.txt   file_e.txt</span>
$
</pre>

  <p>
    We can use the <code>!</code> character with square brackets to mean 
    negation of the following characters inside the square brackets.  For 
    example, <code>file[!46]*</code> would match everything beginning with 
    "file", <em>unless</em> the next character is a 4 or a 6.  Thus, 
    continuing with our example, if we do <code>rm file[!46]*</code>, we 
    will delete everything except <code>file4.txt</code> and 
    <code>file6.txt</code>:
  </p>

<pre>
$ <span class="in">ls</span>
<span class="out">file4.txt   file7.txt    file_b.txt   file_d.txt</span>
<span class="out">file6.txt   file_a.txt   file_c.txt   file_e.txt</span>
$ <span class="in">rm file[!46]*</span>
$ <span class="in">ls</span>
<span class="out">file4.txt   file6.txt</span>
$
</pre>

  <p>
    It's also possible to combine and nest wildcards.  For example, 
    <code>file{4,_?}.txt</code> would match <code>file4.txt</code> 
    and <code>file_?.txt</code>, where <code>?</code> matches any 
    single character. To demonstrate this, let's re-create all of 
    our files:
  </p>

<pre>
$ <span class="in">touch file{4,6,7}.txt file_{a..e}.txt</span>
$ <span class="in">ls</span>
<span class="out">file4.txt   file7.txt    file_b.txt   file_d.txt</span>
<span class="out">file6.txt   file_a.txt   file_c.txt   file_e.txt</span>
$ 
</pre>

  <p>
    Now let's <code>ls file{4,_?}.txt</code>:
  </p>

<pre>
$ <span class="in">ls file{4,_?}.txt</span>
<span class="out">file4.txt   file_b.txt   file_d.txt</span>
<span class="out">file_a.txt   file_c.txt   file_e.txt</span>
$
</pre>

  <p>
    Finally, it is important to understand what happens if a 
    wildcard expression doesn't match any files.  In this case, 
    the wildcard characters are interpreted literally.  For 
    example, if we were to enter <code>ls file[AB].txt</code>,
    the system will first try to find <code>fileA.txt</code> or
    <code>fileB.txt</code>, but when it fails to find either of
    those, it will try to find a file named <code>file[AB].txt</code>.
    We can see that this is the case if we try to 
    <code>ls file[AB].txt</code>:
  </p>

<pre>
$ <span class="in">ls file[AB].txt</span>
<span class="out">ls: file[AB].txt: No such file or directory</span>
$
</pre>

  <p>
    The system tells us that <code>file[AB].txt</code> doesn't exist
    since this was the file it was looking for after it didn't find
    <code>fileA.txt</code> or <code>fileB.txt</code>.  Still not
    convinced?  Let's actually create a file named <code>file[AB].txt</code>.
    To do this, we need some way of telling the computer that we
    actually want the "[" and "]" characters to be in the filename, and
    that we don't mean them as wildcards.
  </p>

  <div class="box">
    <h3>Escaping Special Characters</h3>

    <p>
      Explain about single and double quotes, and backslash
      escaping of characters.  Explain the difference between
      single and double quotes.
      Use the example of creating <code>file[AB].txt</code> by
      either doing
      <code>touch "file[AB].txt"</code>,
      <code>touch 'file[AB].txt'</code>, or
      <code>touch file\[AB\].txt</code>.
    </p>
  </div>

  <p>
    Now we can create the file <code>file[AB].txt</code>:
  </p>
  
<pre>
$ <span class="in">touch "file[AB].txt"</span>
$ <span class="in">ls</span>
<span class="out">file4.txt   file7.txt      file_a.txt   file_c.txt   file_e.txt</span>
<span class="out">file6.txt   file[AB].txt   file_b.txt   file_d.txt</span>
$
</pre>

  <p>
    If we do <code>ls file[AB].txt</code>, it will find the
    file we've just created:
  </p>

<pre>
$ <span class="in">ls file[AB].txt</span>
<span class="out">file[AB].txt</span>
$
</pre>

  <p>
    But if we create a file named <code>fileA.txt</code>,
    this will be found first by the <code>ls</code> command,
    since it first looks for <code>fileA.txt</code> and
    <code>fileB.txt</code>:
  </p>

<pre>
$ <span class="in">touch fileA.txt</span>
$ <span class="in">ls file[AB].txt</span>
<span class="out">fileA.txt</span>
$
</pre>
    
  <p>
    If we really do want to look for something called
    <code>file[AB].txt</code>, and not <code>fileA.txt</code>
    or <code>fileB.txt</code>, then we have to escape the special
    characters "[" and "]".  We can do this:
  </p>

<pre>
$ <span class="in">ls file\[AB\].txt</span>
<span class="out">file[AB].txt</span>
$
</pre>

  <p>
    or this:
  </p>

<pre>
$ <span class="in">ls "file[AB].txt"</span>
<span class="out">file[AB].txt</span>
$
</pre>

  <p>
    Single quotes would work as well in this case.
  </p>

</div>
